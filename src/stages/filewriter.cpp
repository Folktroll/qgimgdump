#include "filewriter.h"

#include <QFileInfo>
#include <QVariant>

#include "exception.h"
#include "inline.h"

using namespace App;

FileWriter::FileWriter(Ctx &ctx) : ctx(ctx) {}

void FileWriter::writeHeader(QFile &dstFile, const SSubMap &submap) {
  if (ctx.config.csvOutput) {
    const QString headerStr = "Feature\tType\tLabel\tLevel\tWKT\tRoadID\n";
    // dstFile.write(ctx.codec->fromUnicode(headerStr));
    dstFile.write(headerStr.toUtf8());
    dstFile.flush();
    return;
  }

  QString idStr = "";
  QMap<QString, QString> levelZoom;
  QString zoomsStr = "";
  QString levelsStr = "";

  for (const auto &ml : submap.mapLevels) {
    levelZoom.insert(QVariant(ml.zoom()).toString(), QVariant(ml.bits).toString());
  }

  idStr = submap.name;

  int index = 0;
  for (auto [key, value] : levelZoom.asKeyValueRange()) {
    levelsStr += QString("Level%1=%2\n").arg(index).arg(value);
    zoomsStr += QString("Zoom%1=%2\n").arg(index).arg(key);
    ++index;
  }

  const QString nameStr = ctx.nameStr.trimmed();

  // @todo: da se izmesti pri parsvaneto!!!
  QString copyrightsStr = "";
  quint32 start = submap.subFiles[submap.isPseudoNt ? "GMP" : "TRE"].offset + submap.hdrTre.size;
  if (quint32 end = submap.subFiles[submap.isPseudoNt ? "GMP" : "TRE"].offset + submap.hdrTre.tre2_offset; end > start) {
    auto crh = readCopyrights(ctx.io.srcFile, start, end);
    copyrightsStr = QString("%1|%2").arg(crh.descr1).arg(crh.descr2);
  }

  QString codepageStr = QString("%1").arg(submap.hdrLbl.codepage);
  QString codingStr = QString("%1").arg(submap.hdrLbl.coding);

  const auto headerStr = QString(
                             "; Generated by qgimgdec 1.0.0\n\n"
                             "[IMG ID]\n"
                             "CodePage=%1\n"
                             "LblCoding=%2\n"
                             "ID=%3\n"
                             "Name=%4\n"
                             "Preprocess=G\n"
                             "TreSize=8096\n"
                             "TreMargin=0.00000\n"
                             "RgnLimit=1024\n"
                             "POIIndex=N\n"
                             "POINumberFirst=N\n"
                             "POIZipFirst=N\n"
                             "MG=N\n"
                             "Routing=N\n"
                             "Copyright=%5\n"
                             "Levels=%6\n%7%8"
                             "[END-IMG ID]\n\n")
                             .arg(codepageStr)
                             .arg(codingStr)
                             .arg(idStr)
                             .arg(nameStr)
                             .arg(copyrightsStr)
                             .arg(levelZoom.count())
                             .arg(levelsStr)
                             .arg(zoomsStr);

  dstFile.write(ctx.codec->fromUnicode(headerStr));
  // dstFile.write(headerStr.toUtf8());
  dstFile.flush();
}

void FileWriter::writeCsv(QFile &dstFile, quint32 level) {
  int count;
  int ptErrs = 0;
  int poErrs = 0;
  int lnErrs = 0;
  int pgErrs = 0;

  count = 0;

  QString strPoints = "";
  for (const RgnPoint &pt : ctx.rgn.points) {
    ++count;

    if (pt.type <= 0) {
      qWarning() << "[pt] Invalid type" << Qt::hex << pt.type;
      ++ctx.stats.warnInvalidType;
      continue;
    }

    strPoints += QString("pt\t%1\t%2\t%3\tPOINT(%4)\t-1\n").arg(pt.type).arg(pt.hasLabel() ? pt.labels.at(0) : "").arg(level).arg(convPtDegStr(pt.pos, true));
  }
  // dstFile.write(ctx.codec->fromUnicode(strPoints));
  dstFile.write(strPoints.toUtf8());
  dstFile.flush();

  count = 0;
  QString strPois = "";
  for (const RgnPoint &po : ctx.rgn.pois) {
    ++count;

    if (po.type <= 0) {
      qWarning() << "[po] Invalid type" << Qt::hex << po.type;
      ++ctx.stats.warnInvalidType;
      continue;
    }

    strPois += QString("pt\t%1\t%2\t%3\tPOINT(%4)\t-1\n").arg(po.type).arg(po.hasLabel() ? po.labels.at(0) : "").arg(level).arg(convPtDegStr(po.pos, true));
  }
  // dstFile.write(ctx.codec->fromUnicode(strPois));
  dstFile.write(strPois.toUtf8());
  dstFile.flush();

  count = 0;
  QString strPolylines = "";
  for (const RgnLine &ln : ctx.rgn.polylines) {
    ++count;

    if (ln.type <= 0) {
      qWarning() << "[ln] Invalid type" << Qt::hex << ln.type;
      ++ctx.stats.warnInvalidType;
      continue;
    }

    strPolylines += QString("ln\t%1\t%2\t%3\tLINESTRING(%4)\t-1\n").arg(ln.type).arg(ln.hasLabel() ? ln.labels.at(0) : "").arg(level).arg(convLnDegStr(ln.points, true, true));
  }
  // dstFile.write(ctx.codec->fromUnicode(strPolylines));
  dstFile.write(strPolylines.toUtf8());
  dstFile.flush();

  count = 0;
  QString strPolygons = "";
  for (const RgnLine &pg : ctx.rgn.polygons) {
    ++count;

    if (pg.type <= 0) {
      qWarning() << "[pg] Invalid type" << Qt::hex << pg.type;
      ++ctx.stats.warnInvalidType;
      ++pgErrs;
      continue;
    }

    strPolygons += QString("pg\t%1\t%2\t%3\tPOLYGON(%4)\t-1\n").arg(pg.type).arg(pg.hasLabel() ? pg.labels.at(0) : "").arg(level).arg(convLnDegStr(pg.points, false, true));
  }
  // dstFile.write(ctx.codec->fromUnicode(strPolygons));
  dstFile.write(strPolygons.toUtf8());
  dstFile.flush();
}

void FileWriter::writeMp(QFile &dstFile, quint32 level) {
  int count = 0;
  int poErrors = 0;
  int ptErrors = 0;
  int lnErrors = 0;
  int pgErrors = 0;
  for (const RgnPoint &pt : ctx.rgn.points) {
    QString tmpPoints;
    ++count;

    if (pt.type <= 0) {
      // qWarning() << "[pt] Invalid type" << Qt::hex << pt.type;
      ++ctx.stats.warnInvalidType;
      continue;
    }

    tmpPoints += QString("[POI]\nType=0x%1\n").arg(pt.type, 0, 16);

    if (pt.hasLabel()) {
      tmpPoints += QString("Label=%1\n").arg(pt.labels.at(0));
      // for (int i = 2; i < pt.labels.size(); ++i) {
      //   tmpPoints += QString("Label%1=%2\n").arg(i).arg(pt.labels.at(i - 1));
      // }
    }

    if (!pt.pos.isNull()) {
      const QString output = convPtDegStr(pt.pos);
      if (output.startsWith(";")) {
        qDebug() << QString("[W] %1").arg(output);
        tmpPoints += output + "\n";
      } else if (output.isEmpty()) {
        continue;
      } else {
        tmpPoints += QString("Data%1=%2\n").arg(level).arg(output);
      }
    }
    tmpPoints += "[END]\n\n";

    dstFile.write(ctx.codec->fromUnicode(tmpPoints));
    // dstFile.write(tmpPoints.toUtf8());
    dstFile.flush();
  }

  count = 0;
  for (const RgnPoint &poi : ctx.rgn.pois) {
    QString tmpPois;
    ++count;

    if (poi.type <= 0) {
      // qWarning() << "[poi] Invalid type" << Qt::hex << poi.type;
      ++ctx.stats.warnInvalidType;
      ++poErrors;
      continue;
    }

    tmpPois += QString("[POI]\nType=0x%1\n").arg(poi.type, 0, 16);

    if (poi.hasLabel()) {
      tmpPois += QString("Label=%1\n").arg(poi.labels.at(0));
      // for (int i = 2; i < poi.labels.size(); ++i) {
      //   tmpPois += QString("Label%1=%2\n").arg(i).arg(poi.labels.at(i - 1));
      // }
    }

    if (!poi.pos.isNull()) {
      const QString output = convPtDegStr(poi.pos);
      if (output.startsWith(";")) {
        qDebug() << QString("[W] %1").arg(output);
        tmpPois += output;
      } else if (output.isEmpty()) {
        continue;
      } else {
        tmpPois += QString("Data%1=%2\n").arg(level).arg(output);
      }
    }
    tmpPois += "[END]\n\n";

    dstFile.write(ctx.codec->fromUnicode(tmpPois));
    // dstFile.write(tmpPois.toUtf8());
    dstFile.flush();
  }

  count = 0;
  // qDebug() << "total polylines:" << polylines.length();
  for (const RgnLine &ln : ctx.rgn.polylines) {
    QString tmpPolylines;
    ++count;

    if (ln.type <= 0) {
      // qWarning() << "[ln] Invalid type" << Qt::hex << ln.type;
      ++ctx.stats.warnInvalidType;
      continue;
    }

    tmpPolylines += QString("[POLYLINE]\nType=0x%1\n").arg(ln.type, 0, 16);

    if (ln.hasLabel()) {
      tmpPolylines += QString("Label=%1\n").arg(ln.labels.at(0));
      for (int i = 2; i < ln.labels.size(); ++i) {
        tmpPolylines += QString("Label%1=%2\n").arg(i).arg(ln.labels.at(i - 1));
      }
    }

    // useless for me
    // if (ln.direction) {
    // tmpPolylines += "DirIndicator=1\n";
    // }

    const QString output = convLnDegStr(ln.points, true);

    if (output.isEmpty()) {
      continue;
    }

    tmpPolylines += QString("Data%1=%2\n").arg(level).arg(output);
    tmpPolylines += "[END]\n\n";

    dstFile.write(ctx.codec->fromUnicode(tmpPolylines));
    // dstFile.write(tmpPolylines.toUtf8());
    dstFile.flush();
  }

  count = 0;
  for (const RgnLine &pg : ctx.rgn.polygons) {
    QString tmpPolygons;
    ++count;

    if (pg.type <= 0) {
      // qWarning() << "[pg] Invalid type" << Qt::hex << pg.type;
      ++ctx.stats.warnInvalidType;
      ++pgErrors;
      continue;
    }

    tmpPolygons += QString("[POLYGON]\nType=0x%1\n").arg(pg.type, 0, 16);

    if (pg.hasLabel()) {
      tmpPolygons += QString("Label=%1\n").arg(pg.labels.at(0));
      // for (int i = 2; i < pg.labels.size(); ++i) {
      //   tmpPolygons += QString("Label%1=%2\n").arg(i).arg(pg.labels.at(i - 1));
      // }
    }

    const QString output = convLnDegStr(pg.points, false);
    if (output.isEmpty()) {
      continue;
    }

    tmpPolygons += QString("Data%1=%2\n").arg(level).arg(output);
    tmpPolygons += "[END]\n\n";

    dstFile.write(ctx.codec->fromUnicode(tmpPolygons));
    // dstFile.write(tmpPolygons.toUtf8());
    dstFile.flush();
  }

  if (poErrors) {
    // qWarning() << "[poi] Invalid type:" << poiErrors;
    ++ctx.stats.warnInvalidType;
  }
}

QString FileWriter::convPtDegStr(const QPointF &pointRad, bool wkt) const {
  QPointF pointDeg = toDegreesSafe(pointRad, ctx);
  const double lat = pointDeg.y();
  const double lng = pointDeg.x();
  thread_local char buffer[64];

  if (wkt) {
    snprintf(buffer, sizeof(buffer), "%.5f %.5f", lng, lat);
  } else {
    snprintf(buffer, sizeof(buffer), "(%.5f,%.5f)", lat, lng);
  }

  return QString::fromLatin1(buffer);
}

QString FileWriter::convLnDegStr(const QPolygonF &polyline, bool isLine, bool wkt) {
  QString result;

  // probably too high a value? (256?)
  if (polyline.size() > 8000) {
    // qDebug() << "[WARN] Too long polyline?" << polyline.size();
    ++ctx.stats.warnPolyOversize;
    return "";
  }
  result.reserve(polyline.size() * 20);

  QPointF pointPrev;
  QPointF firstPoint;
  quint8 pointCount = 0;
  quint8 polyErrors = 0;

  for (const QPointF &point : polyline) {
    if (polyErrors > 50) {
      ++ctx.stats.warnTotals;
      // qDebug() << "[WARN] More then 50 errors:" << totalErrors;
      return "";
    }

    if (pointCount == 0) {
      firstPoint = point;
    } else if (pointPrev == point) {
      // qDebug() << "[INFO] Skipping next duplicate point\n";
      ++ctx.stats.infoSkipDupePoint;
      continue;
    }

    // @investigate: cut the polygon if it forms a figure eight?
    // @investigate: removes the last point if it matches the first one (closed polygon)
    if (isLine == false && pointCount > 2 && point == firstPoint) {
      break;
    }

#ifdef SANITY_CHECK
    if (pointCount && isSuspiciousSegment(pointPrev, point)) {
      // qDebug() << "[WARN] Suspicious segment between points:" << pointPrev << point << pointCount << "/" << polyline.size();
      ++ctx.stats.warnSuspiciousSegment;
      ++polyErrors;
      break;
    }
#endif

    if (pointCount > 0) {
      result += wkt ? ", " : ",";
    }

    pointPrev = point;
    ++pointCount;

    result += convPtDegStr(point, wkt);
  }

  // @investigate: a polygon with 3 points sounds dubious
  if ((isLine && pointCount < 2) || (!isLine && pointCount < 3)) {
    // qDebug() << "[WARN] Does not make much sense: insufficient points";
    return "";
  }

  // if (wkt && !isLine) {
  //   result += ", " + convPtDegStr(firstPoint, wkt);
  // }

  return result;
}

ImgHdr::STre0 FileWriter::readCopyrights(QFile &srcFile, quint32 baseOffset, quint32 limitOffset) const {
  ImgHdr::STre0 result;

  quint32 size = limitOffset - baseOffset;
  QByteArray buf(size, 0);

  srcFile.seek(baseOffset);
  if (srcFile.read(buf.data(), size) != size) {
    qWarning() << "Failed to read copyright block!";
    return result;
  }

  QList<QByteArray> parts = buf.split('\0');

  if (parts.isEmpty() == false) {
    result.descr1 = QString::fromLatin1(parts[0].constData());
  }

  if (parts.size() > 1) {
    result.descr2 = QString::fromLatin1(parts[1].constData());
  }

  return result;
}

void FileWriter::processObjects(QFile &dstFile, const SSubMap &submap) {
  try {
    for (const ImgHdr::SSubDiv &subdiv : submap.subDivs) {
      if (ctx.config.csvOutput) {
        writeCsv(dstFile, subdiv.level);
      } else {
        writeMp(dstFile, subdiv.level);
      }
    }
  } catch (const Exception &e) {
    qDebug() << "Fatal error:" << e.msg;
  }
}

void FileWriter::exportObjects(QFile &srcFile) {
  bool isFirst = true;
  QFile dstFile;
  uint8_t filePart = 0;
  for (const auto &submap : ctx.submaps) {
    QFileInfo ofInfo(ctx.config.outputFile);
    QString dir = ofInfo.path();
    QString fileName = QString("%1\\%2%3.%4").arg(dir).arg(ofInfo.baseName()).arg(ctx.config.splitSubmaps ? "-" + submap.name : "").arg(ofInfo.suffix());
    if (dstFile.isOpen()) {
      QFileInfo fi(dstFile);
      const bool isOversize = fi.size() > ctx.config.maxFileSize;
      if (!ctx.config.csvOutput) {
        if (isOversize) {
          ++filePart;
          fileName = QString("%1\\%2.part%3.%4").arg(dir).arg(ofInfo.baseName()).arg(filePart + 1).arg(ofInfo.suffix());
        }
        if (ctx.config.splitSubmaps || isOversize) {
          dstFile.flush();
          dstFile.close();
          dstFile.setFileName(fileName);
          if (!dstFile.open(QIODevice::WriteOnly | QIODevice::Text)) {
            throw Exception("Error opening output file: " + dstFile.errorString());
          }
          writeHeader(dstFile, submap);

          if (isOversize && filePart == 1) {
            const QString firstPartName = QString("%1\\%2-part%3.%4").arg(dir).arg(ofInfo.baseName()).arg(filePart).arg(ofInfo.suffix());
            if (QFile::exists(firstPartName)) {
              QFile::remove(firstPartName);
            }
            QFile::rename(ctx.config.outputFile, firstPartName);
          }
        }
      }
    } else {
      dstFile.setFileName(fileName);
      if (!dstFile.open(QIODevice::WriteOnly | QIODevice::Text)) {
        throw Exception("Error opening output file: " + dstFile.errorString());
      }
      if (ctx.config.splitSubmaps) {
        writeHeader(dstFile, submap);
      } else if (isFirst) {
        isFirst = false;
        writeHeader(dstFile, submap);
      }
    }

    processObjects(dstFile, submap);
  }

  if (dstFile.isOpen()) {
    dstFile.flush();
    dstFile.close();
  }
}