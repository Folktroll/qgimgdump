#include "filewriter.h"

#include <QFileInfo>
#include <QVariant>
#include <format>

#include "exception.h"
#include "inline.h"

using namespace App;

FileWriter::FileWriter(Ctx &ctx) : ctx(ctx), srcFile(*ctx.io.srcFile) {}

void FileWriter::writeHeader(QFile &dstFile, const SSubMap &subMap) const {
  if (ctx.config.csvOutput) {
    const QString headerStr = "Feature\tType\tLabel\tLevel\tWKT\tRoadID\n";
    // dstFile.write(ctx.codec->fromUnicode(headerStr));
    dstFile.write(headerStr.toUtf8());
    dstFile.flush();
    return;
  }

  QString idStr = "";
  QMap<QString, QString> levelZoom;
  QString zoomsStr = "";
  QString levelsStr = "";

  for (const auto &ml : subMap.mapLevels) {
    levelZoom.insert(QVariant(ml.zoom()).toString(), QVariant(ml.bits).toString());
  }

  idStr = subMap.name;

  int index = 0;
  for (auto [key, value] : levelZoom.asKeyValueRange()) {
    levelsStr += QString("Level%1=%2\n").arg(index).arg(value);
    zoomsStr += QString("Zoom%1=%2\n").arg(index).arg(key);
    ++index;
  }

  const QString nameStr = misc::arrayToQString(ctx.hdrSupp.desc1).trimmed();

  // @todo: da se izmesti pri parsvaneto!!!
  QString copyrightsStr = "";
  quint32 start = subMap.subBlocks[subMap.isPseudoNt ? "GMP" : "TRE"].offset + subMap.hdrTre.size;
  if (quint32 end = subMap.subBlocks[subMap.isPseudoNt ? "GMP" : "TRE"].offset + subMap.hdrTre.tre2_offset; end > start) {
    auto crh = readCopyrights(start, end);
    copyrightsStr = QString("%1|%2").arg(crh.descr1).arg(crh.descr2);
  }

  QString codepageStr = QString("%1").arg(subMap.hdrLbl.codepage);
  QString codingStr = QString("%1").arg(subMap.hdrLbl.coding);

  const auto headerStr = QString(
                             "; Generated by qgimgdec 1.0.0\n\n"
                             "[IMG ID]\n"
                             "CodePage=%1\n"
                             "LblCoding=%2\n"
                             "ID=%3\n"
                             "Name=%4\n"
                             "Preprocess=G\n"
                             "TreSize=8096\n"
                             "TreMargin=0.00000\n"
                             "RgnLimit=1024\n"
                             "POIIndex=N\n"
                             "POINumberFirst=N\n"
                             "POIZipFirst=N\n"
                             "MG=N\n"
                             "Routing=N\n"
                             "Copyright=%5\n"
                             "Levels=%6\n%7%8"
                             "[END-IMG ID]\n\n")
                             .arg(codepageStr)
                             .arg(codingStr)
                             .arg(idStr)
                             .arg(nameStr)
                             .arg(copyrightsStr)
                             .arg(levelZoom.count())
                             .arg(levelsStr)
                             .arg(zoomsStr);

  dstFile.write(ctx.codec->fromUnicode(headerStr));
  // dstFile.write(headerStr.toUtf8());
  dstFile.flush();
}

void FileWriter::writeCsv(QFile &dstFile) {
  QString strBuf;
  for (const auto &[level, rgn] : ctx.rgn.asKeyValueRange()) {
    const auto &[ips, pts, lns, pgs] = rgn;
    strBuf = "";
    for (const auto &pt : pts) {
      strBuf += QString("pt\t%1\t%2\t%3\tPOINT(%4)\t-1\n").arg(pt.type).arg(pt.hasLabel() ? pt.labels.at(0) : "").arg(level).arg(convPtDegStr(pt.node, true));
    }
    // dstFile.write(ctx.codec->fromUnicode(strPt));
    dstFile.write(strBuf.toUtf8());
    dstFile.flush();

    strBuf = "";
    for (const RgnNode &ip : ips) {
      strBuf += QString("pt\t%1\t%2\t%3\tPOINT(%4)\t-1\n").arg(ip.type).arg(ip.hasLabel() ? ip.labels.at(0) : "").arg(level).arg(convPtDegStr(ip.node, true));
    }
    // dstFile.write(ctx.codec->fromUnicode(strBuf));
    dstFile.write(strBuf.toUtf8());
    dstFile.flush();

    strBuf = "";
    for (const RgnPath &ln : lns) {
      strBuf += QString("ln\t%1\t%2\t%3\tLINESTRING(%4)\t-1\n").arg(ln.type).arg(ln.hasLabel() ? ln.labels.at(0) : "").arg(level).arg(convLnDegStr(ln.path, true));
    }
    // dstFile.write(ctx.codec->fromUnicode(strLn));
    dstFile.write(strBuf.toUtf8());
    dstFile.flush();

    strBuf = "";
    for (const RgnPath &pg : pgs) {
      strBuf += QString("pg\t%1\t%2\t%3\tPOLYGON(%4)\t-1\n").arg(pg.type).arg(pg.hasLabel() ? pg.labels.at(0) : "").arg(level).arg(convLnDegStr(pg.path, true));
    }
    // dstFile.write(ctx.codec->fromUnicode(strPg));
    dstFile.write(strBuf.toUtf8());
    dstFile.flush();
  }
}

void FileWriter::writeMp(QFile &dstFile) {
  QString strBuf;
  int i = 0;
  for (const auto &[level, rgn] : ctx.rgn.asKeyValueRange()) {
    ++i;
    const auto &[ips, pts, lns, pgs] = rgn;

    qDebug() << level << i << rgn.pts.size() << rgn.ips.size() << rgn.lns.size() << rgn.pgs.size();
    strBuf = "";
    for (const auto &pt : pts) {
      strBuf += QString("[POI]\nType=0x%1\n").arg(pt.type, 0, 16);

      if (pt.hasLabel()) {
        strBuf += QString("Label=%1\n").arg(pt.labels.at(0));
        // for (int i = 2; i < pt.labels.size(); ++i) {
        //   strBuf += QString("Label%1=%2\n").arg(i).arg(pt.labels.at(i - 1));
        // }
      }

      if (!pt.node.isNull()) {
        const QString output = convPtDegStr(pt.node, false);
        if (output.startsWith(";")) {
          qDebug() << QString("[W] %1").arg(output);
          strBuf += output + "\n";
        } else if (output.isEmpty()) {
          continue;
        } else {
          strBuf += QString("Data%1=%2\n").arg(level).arg(output);
        }
      }
      strBuf += "[END]\n\n";

      dstFile.write(ctx.codec->fromUnicode(strBuf));
      // dstFile.write(strBuf.toUtf8());
      dstFile.flush();
    }

    strBuf = "";
    for (const auto &ip : ips) {
      strBuf += QString("[POI]\nType=0x%1\n").arg(ip.type, 0, 16);

      if (ip.hasLabel()) {
        strBuf += QString("Label=%1\n").arg(ip.labels.at(0));
        // for (int i = 2; i < ip.labels.size(); ++i) {
        //   strIp += QString("Label%1=%2\n").arg(i).arg(ip.labels.at(i - 1));
        // }
      }

      if (!ip.node.isNull()) {
        const QString output = convPtDegStr(ip.node, false);
        if (output.startsWith(";")) {
          qDebug() << QString("[W] %1").arg(output);
          strBuf += output;
        } else if (output.isEmpty()) {
          continue;
        } else {
          strBuf += QString("Data%1=%2\n").arg(level).arg(output);
        }
      }
      strBuf += "[END]\n\n";

      dstFile.write(ctx.codec->fromUnicode(strBuf));
      // dstFile.write(strIp.toUtf8());
      dstFile.flush();
    }

    strBuf = "";
    // qDebug() << "total polylines:" << polylines.length();
    for (const auto &ln : lns) {
      strBuf += QString("[POLYLINE]\nType=0x%1\n").arg(ln.type, 0, 16);

      if (ln.hasLabel()) {
        strBuf += QString("Label=%1\n").arg(ln.labels.at(0));
        for (int i = 2; i < ln.labels.size(); ++i) {
          strBuf += QString("Label%1=%2\n").arg(i).arg(ln.labels.at(i - 1));
        }
      }

      const QString output = convLnDegStr(ln.path, false);

      if (output.isEmpty()) {
        continue;
      }

      strBuf += QString("Data%1=%2\n").arg(level).arg(output);
      strBuf += "[END]\n\n";

      dstFile.write(ctx.codec->fromUnicode(strBuf));
      // dstFile.write(strLn.toUtf8());
      dstFile.flush();
    }

    strBuf = "";
    for (const auto &pg : pgs) {
      strBuf += QString("[POLYGON]\nType=0x%1\n").arg(pg.type, 0, 16);

      if (pg.hasLabel()) {
        strBuf += QString("Label=%1\n").arg(pg.labels.at(0));
        // for (int i = 2; i < pg.labels.size(); ++i) {
        //   strPg += QString("Label%1=%2\n").arg(i).arg(pg.labels.at(i - 1));
        // }
      }

      const QString output = convLnDegStr(pg.path, false);
      if (output.isEmpty()) {
        continue;
      }

      strBuf += QString("Data%1=%2\n").arg(level).arg(output);
      strBuf += "[END]\n\n";

      dstFile.write(ctx.codec->fromUnicode(strBuf));
      // dstFile.write(strPg.toUtf8());
      dstFile.flush();
    }
  }
}

QString FileWriter::convPtDegStr(const QPointF &pointF, const bool &wkt) const {
  if (wkt) {
    return QString::fromStdString(std::format("{:.5f} {:.5f}", pointF.y(), pointF.x()));
  } else {
    return QString::fromStdString(std::format("({:.5f},{:.5f})", pointF.y(), pointF.x()));
  }
}

QString FileWriter::convLnDegStr(const QPolygonF &polygonF, const bool &wkt) const {
  QString result;

  result.reserve(polygonF.size() * 20);

  quint8 pointCount = 0;

  for (const QPointF &point : polygonF) {
    if (pointCount > 0) {
      result += wkt ? ", " : ",";
    }

    ++pointCount;

    result += convPtDegStr(point, wkt);
  }

  return result;
}

ImgHdr::STre0 FileWriter::readCopyrights(quint32 baseOffset, quint32 limitOffset) const {
  ImgHdr::STre0 result;

  quint32 size = limitOffset - baseOffset;
  QByteArray buf(size, 0);

  srcFile.seek(baseOffset);
  if (srcFile.read(buf.data(), size) != size) {
    qWarning() << "Failed to read copyright block!";
    return result;
  }

  QList<QByteArray> parts = buf.split('\0');

  if (parts.isEmpty() == false) {
    result.descr1 = QString::fromLatin1(parts[0].constData());
  }

  if (parts.size() > 1) {
    result.descr2 = QString::fromLatin1(parts[1].constData());
  }

  return result;
}

void FileWriter::exportObjects() {
  bool isFirst = true;
  QFile dstFile;
  uint8_t filePart = 0;
  qDebug() << "exportObjects()";
  for (const auto &subMap : ctx.subMaps) {
    QFileInfo ofInfo(ctx.config.outputFile);
    QString dir = ofInfo.path();
    QString fileName = QString("%1\\%2%3.%4").arg(dir).arg(ofInfo.baseName()).arg(ctx.config.splitSubmaps ? "-" + subMap.name : "").arg(ofInfo.suffix());
    if (dstFile.isOpen()) {
      QFileInfo fi(dstFile);
      const bool isOversize = fi.size() > ctx.config.maxFileSize;
      if (!ctx.config.csvOutput) {
        if (isOversize) {
          ++filePart;
          fileName = QString("%1\\%2.part%3.%4").arg(dir).arg(ofInfo.baseName()).arg(filePart + 1).arg(ofInfo.suffix());
        }
        if (ctx.config.splitSubmaps || isOversize) {
          dstFile.flush();
          dstFile.close();
          dstFile.setFileName(fileName);
          if (!dstFile.open(QIODevice::WriteOnly | QIODevice::Text)) {
            throw Exception("Error opening output file: " + dstFile.errorString());
          }
          writeHeader(dstFile, subMap);

          if (isOversize && filePart == 1) {
            const QString firstPartName = QString("%1\\%2-part%3.%4").arg(dir).arg(ofInfo.baseName()).arg(filePart).arg(ofInfo.suffix());
            if (QFile::exists(firstPartName)) {
              QFile::remove(firstPartName);
            }
            QFile::rename(ctx.config.outputFile, firstPartName);
          }
        }
      }
    } else {
      dstFile.setFileName(fileName);
      if (!dstFile.open(QIODevice::WriteOnly | QIODevice::Text)) {
        throw Exception("Error opening output file: " + dstFile.errorString());
      }
      if (ctx.config.splitSubmaps) {
        writeHeader(dstFile, subMap);
      } else if (isFirst) {
        isFirst = false;
        writeHeader(dstFile, subMap);
      }
    }

    try {
      if (ctx.config.csvOutput) {
        writeCsv(dstFile);
      } else {
        writeMp(dstFile);
      }
    } catch (const Exception &e) {
      qDebug() << "Fatal error:" << e.msg;
    }
  }

  if (dstFile.isOpen()) {
    dstFile.flush();
    dstFile.close();
  }
}